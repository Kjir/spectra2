\documentclass[a4paper,11pt,twoside,openright]{unibo}

\usepackage[italian]{babel}
\usepackage{newlfont}
\usepackage{url}
\usepackage[backref]{hyperref}
\usepackage{amsthm}
\usepackage{acronym}
\textwidth=450pt\oddsidemargin=0pt

\newtheorem{definitions}{Definizione}[chapter]

\acrodef{seti}[SETI]{Search for Extraterrestrial Intelligence}
\acrodef{ipp}[IPP]{Integrated Performance Primitives}
\acrodef{FFT}[FFT]{Fast Fourier Transform}

\begin{document}
\title{Sviluppo di un software per l'analisi real-time di dati
radioastronomici su macchine multicore}
\author{St\'ephane Bisinger}
\date{May 2010}
\acyear{2009 --- 2010}
\supervisor{Antonella Carbonaro}
\thsubject{Programmazione}
\thsession{Prima}
\pagenumbering{roman}

\maketitle
%\include{frontpage}

\tableofcontents

\chapter*{Introduzione}
\label{intro}
\addcontentsline{toc}{chapter}{Introduzione}
\chapter{Basi di elaborazione del segnale}
\pagenumbering{arabic}
\label{math_bkg}
In questo capitolo introdurremo alcuni concetti basilari sull'elaborazione dei
segnali necessari alla comprensione del funzionamento di uno
spettrometro e del suo campo di applicazione. Sapere cosa sia un segnale, come
si estraggono ed elaborano le informazioni in esso contenuto, quali siano i
concetti matematici utilizzati \`e fondamentale per capire il lavoro svolto.\\
Questo materiale introduttivo \`e sufficiente per avere una panoramica sui
concetti teorici utilizzati.

\section{Segnali}
Il nostro corpo \`e in grado di percepire, attraverso i sensi, alcune delle
variazioni nelle propriet\`a fisiche del mondo che ci circonda. Queste variazioni che percepiamo vengono
elaborate dal nostro cervello che riesce a ricavarne informazioni utili: In questo modo
siamo in grado di percepire se fa caldo o freddo, se c'\`e luce, se un oggetto
\`e di un colore piuttosto che un altro, ecc. Va notato che in questi segnali
c'\`e una componente fisica (la temperatura) e l'informazione veicolata
(freddo/caldo). \cite{bertoni}
\begin{definitions} \label{def:signal}
Si dice segnale una qualunque quantit\`a che varia nel tempo o nello spazio.
\end{definitions}
Secondo la precedente definizione, quindi, \`e possibile che un segnale non
contenga informazioni utili: in questo caso ci si riferisce al segnale come
\emph{rumore}. Il rumore \`e anche una componente di interferenza o errore su di
un segnale che si cerca di interpretare.

Un segnale viene quindi rappresentato da una funzione $g = f(c)$, ove:
\begin{itemize}
    \item $g$ \`e una variabile dipendente su di una grandezza fisica in
    relazione al tempo o spazio.
    \item $c$ \`e una varaibile indipendente che rappresenta lo spazio o il
    tempo.
    \item $f$ \`e una funzione che associa ad un valore temporale o spaziale $c$
    la corrispondente quantit\`a $g$.
\end{itemize}

Per semplicit\`a di esposizione, d'ora in avanti si far\`a riferimento
unicamente a segnali in relazione al tempo.
\subsection{I segnali Radio}
\section{ADC: Analog--to--Digital Conversion}
Per interpretare i segnali del mondo che ci circonda, possiamo sfruttare la
velocit\`a di calcolo di un elboratore; tuttavia per poterlo usare, bisogna
essere in grado di rappresentare le informazioni che riceviamo in modo che
l'elaboratore sia in grado di capirle. Per questo motivo dobbiamo trovare un
modo di trasformare un segnale \emph{analogico} in un segnale \emph{digitale}.
\subsection{Segnali analogici, segnali digitali}
Come abbiamo visto nella definzione \ref{def:signal}, i segnali hanno due
componenti: il tempo e il valore assunto dalla grandezza fisica che osserviamo.
Queste due componenti possono assumere un qualunque valore reale, cio\`e il
segnale ha \emph{tempo continuo} e \emph{valori continui}. Tuttavia, in questo
modo il segnale non pu\`o essere rappresentato da un elaboratore, in quanto un
elaboratore pu\`o contenere solamente quantit\`a finite, mentre le componenti
del segnale sono quantit\`a infinite. Per questo motivo bisogna cercare di far
rientrare il segnale in un range di valori finiti e renderlo cos\`i
rappresentabile da un calcolatore.

Per rendere finita la misurazione del tempo, si possono salvare i valori
rilevati ad un intervallo prefissato, ad esempio una volta ogni secondo.
Misurando un segnale per 10 secondi si otterranno cos\`i 10 valori associati ad
ogni secondo. Un segnale di questo tipo ha \emph{tempo discreto}, ma valori
ancora \emph{continui}. Un dispositivo che raccoglie valori con una determinata
frequenza si chiama \emph{campionatore}.

Per rendere i valori finiti, si pu\`o scegliere di utilizzare un certo insieme
di grandezze, ad esempio $1$ e $-1$, e per ogni valore rilevato, associare la
grandezza pi\`u vicina. Quindi se rileviamo i valori $4$, $10$, $-5$ e $-13$,
salviamo il segnale con i valori $1$, $1$, $-1$, $-1$. Cos\`i facendo, il
segnale assume \emph{valori finiti} che sono rappresentabili in un elaboratore,
nell'esempio fatto con l'uso di 1 bit. Un dispositivo che associa ai valori
rilevati il pi\`u vicino valore rappresentabile dall'elaboratore si chiama
\emph{quantizzatore}.

Un segnale che ha tempo \emph{continuo} e valori \emph{continui} si chiama
\emph{segnale analogico}, mentre un segnale con tempo \emph{discreto} e valori
\emph{finiti} si chiama \emph{segnale digitale}.

Come \`e facile intuire, la conversione da analogico a digitale pu\`o introdurre
degli \emph{errori}, cio\`e del \emph{rumore}, in quanto la versione digitale di
un segnale analogico \`e una approssimazione. Fortunatamente \`e possibile
valutare questo margine di errore e ridurlo a seconda delle necessit\`a sia
aumentando il numero di bit usati per rappresentare i valori nel tempo, sia
aumentando il numero di rilevazioni effettuate nello spazio temporale di
osservazione.
\subsection{Teorema del Campionamento}
\section{La Trasformata di Fourier}
\section{La Trasformata Discreta di Fourier}
\section{FFT: Fast Fourier Transform}
Taken from \cite{bertoni}
\chapter{Progettazione e architettura}
\label{outline}
Nel momento della progettazione, sono stati prefissati alcuni punti importanti:
il programma avrebbe dovuto essere veloce, modulare e parametrizzabile sulle
caratteristiche pi\`u rilevanti dei segnali. L'utilizzo del C++ come linguaggio di
sviluppo ha portato alla scelta di scrivere preferibilmente codice orientato
agli oggetti e di sfruttare al massimo gli strumenti offerti dalla libreria
boost\footnote{\url{http://www.boost.org/}}, praticamente uno standard per qualunque programma C++ di una certa
complessit\`a.
\section{Obiettivi}
Il funzionamento desiderato per l'applicazione \`e piuttosto semplice: il
programma legge dei dati da una sorgente, li trasforma con una \ac{FFT} ed
eventualmente applica qualche filtro, infine scrive l'output su una qualche
destinazione. Un importante obiettivo \`e che la manipolazione dei segnali
avvenga in real---time, cio\`e che le operazioni vengano calcolate abbastanza
velocemente da riuscire ad elaborare i dati man mano che arrivano dalla
sorgente.

Uno degli utilizzi principali ipotizzati per lo spettrometro \`e l'elaborazione
di dati per il progetto \ac{seti}. In questo caso, i dati vengono recuperati da
una speciale scheda di acquisizione dedicata\footnote{L'hardware necessario a
sviluppare questo aspetto dell'applicazione non era disponibile, perci\`o
    l'implementazione dell'acquisizione di dati \ac{seti} \`e stata lasciata
    come possibile sviluppo futuro. cfr. \ref{seti}}.
Le caratteristiche fondamentali della \ac{FFT} sono una lunghezza del segnale
piuttosto importante (circa $2^{23}$), un basso numero di integrazioni e la
possibilit\`a di ricevere i dati sporadicamente, cio\`e il data rate pu\`o
essere mantenuto basso.

Un'altro utilizzo \`e l'analisi di space debris(?) dove la sorgente di dati sono
dei pacchetti UDP e la \ac{FFT} \`e caratterizzata da segnali di lunghezza contenuta
(circa $2^{15}$) con molte integrazioni (circa $100000$). In questo caso \`e
importante riuscire a mantenere il data rate alto, quindi l'elaborazione deve
essere il pi\`u veloce possibile.

\section{Gerarchia di classi}
Per raggiungere gli obiettivi prefissati, sono necessarie alcune classi per
astrarre alcuni concetti. In particolare ci sono tre componenti fondamentali:
\begin{itemize}
\item Una sorgente da cui prendere dati
\item Filtri o trasformazioni da applicare al segnale
\item Una destinazione su cui scrivere l'output
\end{itemize}
Per questo motivo ci sono tre classi astratte che rappresentano questi tre
concetti: \texttt{SourceFilter}, \texttt{ProcessFilter} e \texttt{SinkFilter}.
\subsection{SourceFilter}
Una sorgente ha un unico metodo assolutamente necessario che serve a leggere i
dati. Una sottoclasse di \texttt{SourceFilter}, ad esempio, \`e il server UDP
(\texttt{udp\_sock}), che pu\`o essere usata da qualunque codice generico che
faccia riferimento unicamente all'interfaccia astratta. Se si creasse un'altra
sottoclasse di \texttt{SourceFilter} e la si sostituisse a \texttt{udp\_sock} si
otterrebbero i dati da un'altra fonte senza dover cambiare una riga di codice al
di fuori della inizializzazione.
\subsection{ProcessFilter}
Un \texttt{ProcessFilter} rappresenta una qualunque elaborazione intermedia del
segnale, sia essa una trasformata di Fourier o un filtro passa---basso o una
qualunque altra manipolazione. Siccome in questa fase si prende un segnale e lo
si manipola in qualche maniera, l'interfaccia richiede un metodo
\texttt{transform} che abbia in input i dati da elaborare e scriva su un vettore
di output specificato. I filtri sono per natura concatenabili, quindi per
gestire questa coda serve una classe \texttt{FilterChain} che si occupi di
passare l'elaborazione attraverso una coda di filtri precedentemente
selezionati.
\subsection{SinkFilter}
Le destinazioni hanno bisogno di un unico metodo di interfaccia: \texttt{write}.
In modo simile al \texttt{SourceFilter}, una qualunque implementazione della
classe astratta \texttt{SinkFilter} pu\`o essere intercambiata con un'altra
senza dover apportare modifiche al codice, permettendo di scegliere il
dispositivo di memorizzazione pi\`u adeguato agli scopi perseguiti.
\subsection{Classi di supporto}
Ci sono altre classi nel progetto che servono pi\`u come supporto che non come
architettura dell'applicazione. Ad esempio nella classe \texttt{IPP} sono
raccolti alcuni dei metodi di allocazione/deallocazione di memoria della
libreria \ac{ipp}. Altre classi sono state create per gestire i buffer di
input/output e sincronizzare la scrittura dei vari thread su questi vettori.
\chapter{Sviluppo del progetto}
\label{sw_devel}
\section{Librerie}
See \ref{tests}.
\chapter{Risultati e considerazioni}
\label{tests}
\chapter{Conclusioni e sviluppi futuri}
\label{conclusions}
\section{Sviluppi futuri}
\subsection{\ac{seti}}
\label{seti}
Implementazione acquisizione.
\bibliographystyle{alpha}
\bibliography{thesis}
\end{document}
