\chapter{Progettazione e architettura}
\label{outline}
Nel momento della progettazione, sono stati prefissati alcuni punti importanti:
il programma avrebbe dovuto essere veloce, modulare e parametrizzabile sulle
caratteristiche pi\`u rilevanti dei segnali. L'utilizzo del C++ come linguaggio di
sviluppo ha portato alla scelta di scrivere preferibilmente codice orientato
agli oggetti e di sfruttare al massimo gli strumenti offerti dalla libreria
boost\footnote{\url{http://www.boost.org/}}, praticamente uno standard per qualunque programma C++ di una certa
complessit\`a.
\section{Obiettivi}
Il funzionamento desiderato per l'applicazione \`e piuttosto semplice: il
programma legge dei dati da una sorgente, li trasforma con una \ac{FFT} ed
eventualmente applica qualche filtro, infine scrive l'output su una qualche
destinazione. Un importante obiettivo \`e che la manipolazione dei segnali
avvenga in real---time, cio\`e che le operazioni vengano calcolate abbastanza
velocemente da riuscire ad elaborare i dati man mano che arrivano dalla
sorgente.

Uno degli utilizzi principali ipotizzati per lo spettrometro \`e l'elaborazione
di dati per il progetto \ac{seti}. In questo caso, i dati vengono recuperati da
una speciale scheda di acquisizione dedicata\footnote{L'hardware necessario a
sviluppare questo aspetto dell'applicazione non era disponibile, perci\`o
    l'implementazione dell'acquisizione di dati \ac{seti} \`e stata lasciata
    come possibile sviluppo futuro. cfr. \ref{seti}}.
Le caratteristiche fondamentali della \ac{FFT} sono una lunghezza del segnale
piuttosto importante (circa $2^{23}$), un basso numero di integrazioni e la
possibilit\`a di ricevere i dati sporadicamente, cio\`e il data rate pu\`o
essere mantenuto basso.

Un'altro utilizzo \`e l'analisi di space debris(?) dove la sorgente di dati sono
dei pacchetti UDP e la \ac{FFT} \`e caratterizzata da segnali di lunghezza contenuta
(circa $2^{15}$) con molte integrazioni (circa $100000$). In questo caso \`e
importante riuscire a mantenere il data rate alto, quindi l'elaborazione deve
essere il pi\`u veloce possibile.

\section{Gerarchia di classi}
Per raggiungere gli obiettivi prefissati, sono necessarie alcune classi per
astrarre alcuni concetti. In particolare ci sono tre componenti fondamentali:
\begin{itemize}
\item Una sorgente da cui prendere dati
\item Filtri o trasformazioni da applicare al segnale
\item Una destinazione su cui scrivere l'output
\end{itemize}
Per questo motivo ci sono tre classi astratte che rappresentano questi tre
concetti: \\
\texttt{SourceFilter}, \texttt{ProcessFilter} e \texttt{SinkFilter}.
\subsection{SourceFilter}
Una sorgente ha un unico metodo assolutamente necessario che serve a leggere i
dati. Una sottoclasse di \texttt{SourceFilter}, ad esempio, \`e il server UDP
(\texttt{udp\_sock}), che pu\`o essere usata da qualunque codice generico che
faccia riferimento unicamente all'interfaccia astratta. Se si creasse un'altra
sottoclasse di \texttt{SourceFilter} e la si sostituisse a \texttt{udp\_sock} si
otterrebbero i dati da un'altra fonte senza dover cambiare una riga di codice al
di fuori della inizializzazione.
\subsection{ProcessFilter}
Un \texttt{ProcessFilter} rappresenta una qualunque elaborazione intermedia del
segnale, sia essa una trasformata di Fourier o un filtro passa---basso o una
qualunque altra manipolazione. Siccome in questa fase si prende un segnale e lo
si manipola in qualche maniera, l'interfaccia richiede un metodo
\texttt{transform} che abbia in input i dati da elaborare e scriva su un vettore
di output specificato. I filtri sono per natura concatenabili, quindi per
gestire questa coda serve una classe \texttt{FilterChain} che si occupi di
passare l'elaborazione attraverso una coda di filtri precedentemente
selezionati.
\subsection{SinkFilter}
Le destinazioni hanno bisogno di un unico metodo di interfaccia: \texttt{write}.
In modo simile al \texttt{SourceFilter}, una qualunque implementazione della
classe astratta \texttt{SinkFilter} pu\`o essere intercambiata con un'altra
senza dover apportare modifiche al codice, permettendo di scegliere il
dispositivo di memorizzazione pi\`u adeguato agli scopi perseguiti.
\subsection{Contenitori di dati}
Sono state progettate alcune classi al fine di astrarre i dati e assicurarne la corretta sincronizzazione.
\subsubsection{SrcType}
\texttt{SrcType} \`e una struttura con un costruttore, un destruttore ed un operatore di assegnamento. Tra i membri di questa struttura c'\`e una mutex per eseguire operazioni in mutua esclusione, ove necessario. Questa struttura \`e un wrapper di un puntatore, ideale per essere usata all'interno di un circular buffer.
\subsubsection{FFTBuf}
La classe \texttt{FFTBuf} \`e un vettore su cui vanno scritti i risultati di una o pi\`u trasformazioni di Fourier. Al momento della costruzione, si indica la lunghezza del segnale da salvare e il numero di integrazioni che si prevede di fare; a questa maniera \`e possibile assegnare questo buffer a tanti thread quante dovranno essere le integrazioni da fare. La classe offre strumenti anche per tener traccia di quante integrazioni sono gi√† state effettuate e sapere cos\`i se il buffer \`e pronto per essere scritto su output.
\subsubsection{List}
La classe \texttt{List} \`e un semplice wrapper attorno ad una lista della libreria standard. Questa classe assicura un comportamento corretto in ambienti multithreading e aggiunge alcuni metodi per semplificare la coordinazione con gli altri thread.
\subsection{Wrapper di librerie}
La classe \texttt{IPP} esiste solo per fornire un wrapper C++ alle librerie \ac{ipp}, scritte in C. Tramite overloading \`e stato possibile utilizzare lo stesso nome per funzioni che operano su tipi di dati differenti, lasciando al compilatore il compito di invocare la funzione specifica pi\`u adeguata.
