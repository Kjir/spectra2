\chapter{Progettazione e architettura}
\label{outline}
Nel momento della progettazione, sono stati prefissati alcuni punti importanti:
il programma avrebbe dovuto essere veloce, modulare e parametrizzabile sulle
caratteristiche pi\`u rilevanti dei segnali. L'utilizzo del C++ come linguaggio di
sviluppo ha portato alla scelta di scrivere preferibilmente codice orientato
agli oggetti e di sfruttare al massimo gli strumenti offerti dalla libreria
boost\footnote{\url{http://www.boost.org/}}, praticamente uno standard per qualunque programma C++ di una certa
complessit\`a.
\section{Obiettivi}
Il funzionamento desiderato per l'applicazione \`e piuttosto semplice: il
programma legge dei dati da una sorgente, li trasforma con una \ac{FFT} ed
eventualmente applica qualche filtro, infine scrive l'output su una qualche
destinazione. Un importante obiettivo \`e che la manipolazione dei segnali
avvenga in real---time, cio\`e che le operazioni vengano calcolate abbastanza
velocemente da riuscire ad elaborare i dati man mano che arrivano dalla
sorgente.

Uno degli utilizzi principali ipotizzati per lo spettrometro \`e l'elaborazione
di dati per il progetto \ac{seti}. In questo caso, i dati vengono recuperati da
una speciale scheda di acquisizione dedicata\footnote{L'hardware necessario a
sviluppare questo aspetto dell'applicazione non era disponibile, perci\`o
    l'implementazione dell'acquisizione di dati \ac{seti} \`e stata lasciata
    come possibile sviluppo futuro. cfr. \ref{seti}}.
Le caratteristiche fondamentali della \ac{FFT} sono una lunghezza del segnale
piuttosto importante (circa $2^{23}$), un basso numero di integrazioni e la
possibilit\`a di ricevere i dati sporadicamente, cio\`e il data rate pu\`o
essere mantenuto basso.

Un'altro utilizzo \`e l'analisi di space debris(?) dove la sorgente di dati sono
dei pacchetti UDP e la \ac{FFT} \`e caratterizzata da segnali di lunghezza contenuta
(circa $2^{15}$) con molte integrazioni (circa $100000$). In questo caso \`e
importante riuscire a mantenere il data rate alto, quindi l'elaborazione deve
essere il pi\`u veloce possibile.

\section{Gerarchia di classi}
Per raggiungere gli obiettivi prefissati, sono necessarie alcune classi per
astrarre alcuni concetti. In particolare ci sono tre componenti fondamentali:
\begin{itemize}
\item Una sorgente da cui prendere dati
\item Filtri o trasformazioni da applicare al segnale
\item Una destinazione su cui scrivere l'output
\end{itemize}
Per questo motivo ci sono tre classi astratte che rappresentano questi tre
concetti: \texttt{SourceFilter}, \texttt{ProcessFilter} e \texttt{SinkFilter}.
\subsection{SourceFilter}
Una sorgente ha un unico metodo assolutamente necessario che serve a leggere i
dati. Una sottoclasse di \texttt{SourceFilter}, ad esempio, \`e il server UDP
(\texttt{udp\_sock}), che pu\`o essere usata da qualunque codice generico che
faccia riferimento unicamente all'interfaccia astratta. Se si creasse un'altra
sottoclasse di \texttt{SourceFilter} e la si sostituisse a \texttt{udp\_sock} si
otterrebbero i dati da un'altra fonte senza dover cambiare una riga di codice al
di fuori della inizializzazione.
\subsection{ProcessFilter}
Un \texttt{ProcessFilter} rappresenta una qualunque elaborazione intermedia del
segnale, sia essa una trasformata di Fourier o un filtro passa---basso o una
qualunque altra manipolazione. Siccome in questa fase si prende un segnale e lo
si manipola in qualche maniera, l'interfaccia richiede un metodo
\texttt{transform} che abbia in input i dati da elaborare e scriva su un vettore
di output specificato. I filtri sono per natura concatenabili, quindi per
gestire questa coda serve una classe \texttt{FilterChain} che si occupi di
passare l'elaborazione attraverso una coda di filtri precedentemente
selezionati.
\subsection{SinkFilter}
Le destinazioni hanno bisogno di un unico metodo di interfaccia: \texttt{write}.
In modo simile al \texttt{SourceFilter}, una qualunque implementazione della
classe astratta \texttt{SinkFilter} pu\`o essere intercambiata con un'altra
senza dover apportare modifiche al codice, permettendo di scegliere il
dispositivo di memorizzazione pi\`u adeguato agli scopi perseguiti.
\subsection{Classi di supporto}
Ci sono altre classi nel progetto che servono pi\`u come supporto che non come
architettura dell'applicazione. Ad esempio nella classe \texttt{IPP} sono
raccolti alcuni dei metodi di allocazione/deallocazione di memoria della
libreria \ac{ipp}. Altre classi sono state create per gestire i buffer di
input/output e sincronizzare la scrittura dei vari thread su questi vettori.
