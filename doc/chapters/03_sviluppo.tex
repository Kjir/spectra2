\chapter{Sviluppo del progetto}
\label{sw_devel}

Durante lo sviluppo del progetto si ha fatto uso di librerie e strumenti
software per semplificare il pi\`u possibile il lavoro da svolgere ed ottenere
il massimo delle prestazioni possibili. 

\section{Librerie}
L'utilizzo delle giuste librerie permette di sviluppare pi\`u velocemente i
propri progetti, ottenere prestazioni spesso migliori rispetto ad una soluzione
sviluppata in proprio e sicuramente avere pi\`u certezze riguardo al corretto
funzionamento delle parti attenenti alla libreria.

\subsection{Boost}
Le librerie Boost\footnote{\url{http://www.boost.org/}} sono molto usate nella
programmazione in \CC perch\'e implementano moltissime funzioni di comune
utilizzo fornendo una interfaccia molto semplice. L'ottima qualit\`a di queste
librerie \`e confermato dal fatto che spesso alcune sue componenti vengono
integrate nello standard \CC. Queste librerie sono basate sulla versione ANSI
del \CC, rendendole compatibili con qualunque compilatore che implementi gli
standard ANSI.In questo progetto vengono utilizzate principalmente per
semplificare la lettura di argomenti da linea di comando, la lettura/scrittura
di files, le comunicazioni di rete e il multithreading.

\subsection{\ac{ipp}}
Le Integrated Performance
Primitives\footnote{\url{http://software.intel.com/en-us/intel-ipp/}} sono delle
librerie che implementano un insieme molto completo di funzioni e algoritmi
relativi al processamento di segnali e crittografia. In particolare implementano
funzioni utili al processamento di segnali audio (filtri, codifiche audio,
compressione dei dati, ecc.), funzioni per il processamento di immagini
(trasformazioni, codifica video, ecc.), funzioni per calcoli su matrice e
funzioni crittografiche (crittografia simmetrica, asimmetrica, funzioni hash,
ecc.).  Il vantaggio delle IPP \`e che offrono un ampio spettro di funzioni che
coprono praticamente tutte le necessit\`a nel processamento dei segnali, oltre
ad essere ottimizzate per processori Intel. Inoltre sono state scritte in modo
da essere naturalmente utilizzabili in ambienti multithreaded, sfruttando tutte
le potenzialit\`a di processori multicore o processori multipli. Tutti questi
fattori hanno concorso nell'adozione di questa libreria al posto di altre
librerie concorrenti. Questa libreria \`e l'unico componente non Open Source
utilizzato nell'intero progetto, anche se il suo utilizzo \`e gratuito per usi
accademici. Le librerie alternative potrebbero essere comparate per verificare
l'effettiva qualit\`a a livello di prestazioni\footnote{cfr. paragrafo
\ref{altlib}}.

\subsubsection{Multithreading e prestazioni nelle \ac{ipp}}
Le \ac{ipp} sono state sviluppate con l'intenzione di sfruttare a pieno le
istruzioni \ac{SIMD} e \ac{SSE} presenti nei moderni processori. Queste
istruzioni permettono di effettuare operazioni su vettori in parallelo,
guadagnando grandi vantaggi prestazionali in alcuni tipi di operazioni, tra cui
anche i calcoli necessari per l'elaborazione di segnali. Siccome diversi
processori supportano diversi tipi di istruzioni, possono esistere diverse
implementazioni di alcune funzione in base al tipo di istruzioni supportate. Per
selezionare automaticamente la funzione corretta, le \ac{ipp} dispongono di un
dispatcher che, durante l'inizializzazione a run-time, individuano le capacit\`a
del processore e quindi la categoria di libreria da utilizzare. Questo permette
di usare trasparentemente le funzioni di libreria sfruttando sempre
l'implementazione pi\`u efficiente per il processore utilizzato.

Alcune funzioni di base della libreria sfruttano il threading per migliorare le
proprie prestazioni, in particolare sfruttando le librerie OpenMP sviluppate da
Intel. Quando si utilizza la versione multi-threaded della libreria, i thread
vengono automaticamente inizializzati al numero di processori e core presenti: a
questo modo la libreria avvier\`a al massimo tanti thread quante sono le unit\`a
di calcolo presenti nel sistema, evitando di sovracaricare il sistema e
ottenendo cos\`i la migliore prestazione possibile dal sistema in uso. Sono
presenti anche due funzioni, \texttt{ippSetNumThreads()} e
\texttt{ippGetNumThreads()}, che permettono di manipolare il numero di threads
utilizzati dalla libreria. Il numero di thread non sar\`a mai maggiore rispetto
al numero di unit\`a di calcolo del sistema, anche se impostati manualmente ad
un valore maggiore.

Tutte le funzioni IPP sono thread-safe, cio\`e possono essere usate da diversi
thread di esecuzione contemporaneamente senza che questo implichi un qualunque
malfunzionamento.\footnote{Per approfondimenti, cfr.
\url{http://software.intel.com/en-us/articles/threading-and-intel-integrated-performance-primitives/}}


\section{Codice pre-esistente}
Parte del codice del progetto \`e stato prelevato dal software sviluppato in
fase di tirocinio, sempre presso l'Istituto di Radioastronomia di Medicina.
Questo codice ha permesso di ridurre notevolmente il tempo dedicato allo
sviluppo del calcolo della \ac{FFT} lasciando maggior tempo per una corretta
implementazione delle altre parti. Questo codice \`e stato adattato per
funzionare in un contesto multithreaded e per accettare input da diverse fonti.

\section{Gestione del threading}
Quando si introduce il threading in una applicazione, ci sono delle situazioni
che vanno prese in considerazione: avere diversi thread pu\`o portare problemi
normalmente assenti e non facilmente identificabili. Inoltre alcuni problemi
legati al threading possono essere difficili da riprodurre perch\'e  dipendono
dalla schedulazione dei thread da parte del sistema operativo, quindi sono al di
fuori dal controllo del programmatore. Per questo motivo esistono alcune
tecniche di programmazione che permettono di evitare problemi quando thread
diversi devono condividere alcuni dati.
\subsection{Mutua esclusione}
\lstinputlisting[firstline=3,lastline=12,float,caption=Variabili della
lista,label=lst:vars]{../src/list.hpp}
Con la mutua esclusione si assicura che quando un thread accede ad una parte di
dati protetta, nessun altro thread pu\`o accedervi contemporaneamente. La mutua
esclusione \`e stata implementata, ad esempio, come wrapper attorno alla
struttura standard \texttt{std::list} per renderla utilizzabile da pi\`u thread
contemporaneamente.

Per rendere la lista thread-safe, servono tre variabili: una contiene la lista
standard, una per la mutex ed una per la condition variable, come mostrato nel
listato \ref{lst:vars}

Una mutex, abbreviazione di \textbf{mut}utal \textbf{ex}clusion, serve appunto
per poter bloccare l'accesso all'oggetto da parte di altri thread e per
rilasciare il blocco quando si ha finito. Le funzioni presenti in
\texttt{std::list} vengono reimplementate sfruttando la mutex per assicurare un
comportamento corretto in caso di multithreading: troviamo un buon esempio nel
metodo \texttt{empty()} presentato nel listato \ref{lst:empty}.
\lstinputlisting[firstline=24,lastline=28,float,caption=Implementazione di
\texttt{empty()},label=lst:empty]{../src/list.hpp}

La creazione dell'oggetto di tipo \texttt{boost::mutex::scoped\_lock} sospende
l'esecuzione del thread se ci sono gi\`a altri thread che possiedono l'esclusiva
sull'oggetto \texttt{\_mut}, altrimenti acquisisce il diritto di esclusiva
sulla mutex e procede con l'operazione. Nel distruttore dell'oggetto
\texttt{lock} avviene il rilascio della mutex, quindi non appena l'oggetto
finisce fuori contesto --- cio\`e dopo il \texttt{return} --- il distruttore
viene chiamato e la mutex viene liberata, lasciando libero accesso ad altri
threads.

\subsection{Wait/notify}
Abbiamo visto nel paragrafo \ref{threadout} come il thread di output si metta in
attesa sulla lista quando questa \`e vuota. Il codice presente nel thread di
output \`e simile a questo:
\begin{lstlisting}
while(list.empty()) {
    list.wait();
}
//Do something
\end{lstlisting}

Questo codice mette in uno stato ``dormiente'' il thread, lasciando il posto
agli altri thread e ottimizzando cos\`i il tempo di scheduling assegnato al
programma: l'alternativa sarebbe fare un ciclo continuo --- detto \emph{busy waiting} --- per verificare la stessa
condizione ripetutamente, ma in questo modo si sprecherebbero tantissime risorse
su un controllo che non cambier\`a risultato prima che avvengano altre cose. Per
monitorare lo stato di questa condizione, si pu\`o utilizzare una
\texttt{boost::condition\_variable}, come mostrato nel listato \ref{lst:cond_wait}.
\lstinputlisting[firstline=50,lastline=53,float,caption=Uso della
\texttt{boost::condition\_variable},label=lst:cond_wait]{../src/list.hpp}
Il codice inizialmente acquisisce un lock esclusivo sulla mutex, poi si mette in
attesa sulla \texttt{condition\_variable} \texttt{\_empty}. A questo punto
il lock viene rilasciato ed il thread si mette in attesa, senza occupare risorse
sul sistema. Per risvegliare questo thread bisogna notificarlo del fatto che la
condizione su cui stava aspettando `e stata modificata, quindi quando si
inserisce un nuovo elemento nella lista bisogna anche notificare il thread di
output che la lista non \`e pi\`u vuota, come illustrato nel listato
\ref{lst:notify}. Il metodo \texttt{notify\_one()} \`e definito come:
\begin{lstlisting}[frame=none]
    void notify_one() { _empty.notify_one(); }
\end{lstlisting}
Utilizza, quindi, la \texttt{condition\_variable} per notificare uno dei thread
in attesa sulla variabile stessa. A questo punto il thread di output si
risveglia, aspetta di poter riacquisire il lock sull'oggetto e continua con
l'esecuzione. A questo punto la condizione \texttt{list.empty()} dovrebbe
essere falsa e il thread pu\`o procedere con il suo lavoro.
\lstinputlisting[firstline=34,lastline=38,float,caption=Notifica di inserimento
di un nuovo elemento in lista,label=lst:notify]{../src/list.hpp}

\subsection{Debugging}
